undefined + 1; // Ответ: NaN;
// Операция сложения с undefined приводит к получению значения NaN.
// Сам (undefined) пытается перевести в число, а если его перевести в число будет NaN (так как это не есть число).
// И при сложении "не числа" с "числом" мы получаем ответ NaN.


'true' == true // Ответ: False
// Тут применяется не строгое сравнение при котором js не преобразует оба операнда к одному типу данных, они имеют разные типы.
// В данном случае 'true' имеет тип (String), а true имеет тип (Boolean), по этому они не равны.


false == 'false' // Ответ: False
// Тут один операнд является логическим значением (false), а второй строкой ('false').
// При сравнении, строка 'false' будет преобразована в логическое значение. Любая непустая строка, включая 'false', преобразуется в логическое значение true.
// Таким образом, после приведения обоих операндов к логическому типу, false не равен true. Следовательно, результатом сравнения false == 'false' будет (false)


null == '' // Ответ: False
// Так как (null) имеет тип данных "object" Я проверил с помощью ("typeof"), а ''(пустая строка) и тип ("String")
// и когда происходит не строгое сравнение ("null") может быть равен только (null) или (undefined),
// то таким образом получается что null не равен пустой строке.


3 ** (9 / 3); // Ответ: 27
// Сначало выполнится условие в скобках  это будет (3). А потом приравняется к степени (3 ** 3 ).


!!'false' == !!'true' // Ответ: true
// У нас идет преобразование типов в булевые значения. У нас идет 2е отрицание (!!'False') будет равно true, а (!!'true') будет тоже равно true.
// И получается у нас не строгое сравнение ( true == true).
//У нас будет тут преобразование строк в логическое значение - 'false' преобразуется в true так как непустая строка в логическом контексте интерпретируется как true,
// а 'true' по тойже логике будет равна true.


0 || '0' && 1 // Ответ: 1
// Тут выполняется пример с начало && так как он приоритетней чем ||.
// То есть ('0' && 1) эта операция нам вернет с помощью оператора && операнд 1.
// Потом выполнится действие ( 0 || 1). Если первый операнд ложный. В нашем случае "0" интерпритируется на как ложное значени по этому ответ мы получим (1).



1 < 2 < 3 // Ответ: true
// как я понимаю что (1 < 2) вернет нам (true), так как 1 меньше 2х.
// Потом пойдем сравнение (true < 3), то есть js попробует преобразовать true в число, а это (1).
// Таким образом (true < 3) преобразуется в чисто и получается 1 < 3 что есть правда.


'foo'+ + +'bar' // Ответ: 'fooNaN'
// По спольку (строка 'bar' тип String) оно не может преобразоватся в число за счет унарного + то мы получим (NaN)
// Теперь выражение выглядит так ('foo' + NaN ). Когда происходит конкатенация строк с (NaN), результатом будет строкой ('fooNaN')



3 ** 2 / 3; // Ответ: 3
// Оператор (**)  имеет приоритет перед делением (/). По этому этот пример будет выполнятся как и написано с лево на право.
// и того получается 3 ** 2 = 9, а 9 / 3 = 3.  



1 < 2 > 3 // Ответ: false
// 1 < 2 -  Вернет ответ true. Потом true > 3 -  тут будет сравнение логического значение (true) с числом 3.
// В логическом контексте true будет преобразовано к 1. Таким образом мы получим выражение 1 > 3 что является не правильным. Так как 1 не больше 3.


(+null == false) < 1; // Ответ: False
// Унарный оператор + превратит null в число (0). Мы получаем результат (0 == false).
// При сравнении с логическим значением (false), (0) будет преобразовано в логическое значение (false).
// таким образом нам вернется (true). Получается мы получаем выражение (true < 1).
// А при сравнении логического значения с числом оно преобразуется в число. То есть если true  = 1, то выражение мы получаем 1 < 1.
// А так как 1 не меньше 1, мы получаем (false).


false && true || true // Ответ: true
// Тут операторы располежны в приоритете с лево на право, по этому будет пример будет выполняться так как он записан.
// (false && true) - вернет нам первый ложный операнд. тут первый у нас операнд (false), по этому результат нам вернется (false).
// Получаем пример (False || true). c помощью оператора (||) возвращаем первый истинный операнд.
// Так как у нас первый операнд (False), а он ложный, то мы получим ответ (true). 

false && (true || true); // Ответ: false
// Сначало действие выполнится в скобках. Операция вернет ответ "true"( потому что оператор (||) возвращает (true) если есть хоть 1 истинный операнд).
// Потому у нас получится пример (false && true). Операция вернет "false"( Потому что оператор (&&) возвращает ответ (false) если хоть 1 операнд ложный), а у нас есть "false". 


(+null == false) < 1 ** 5; // Ответ: False
// Первое действие будет выполнено в скобках .За счет унарного оператора (+) null преобразуется в (0).
// (False)будет приводится к числу, мы получаем (0 == 0), по этому ответ получим (true).
// Дальше мы получаем выражение (true < 1 ** 5), первое что мы делаем возводим в степень
// 1 ** 5 =  1. Получаем выражение (true < 1), При сравнении с числом (true) преобразуется в 1.
// Так как 1 не меньше 1 мы получаем (false).